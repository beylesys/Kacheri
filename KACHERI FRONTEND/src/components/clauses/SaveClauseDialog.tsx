// KACHERI FRONTEND/src/components/clauses/SaveClauseDialog.tsx
// Modal dialog for saving selected text as a reusable clause in the workspace library.
//
// Pre-fills content from editor selection. Users can name, describe, categorize,
// and tag the clause. AI-assisted title/description generated by backend if left empty.
//
// Uses clauseActionsApi.fromSelection() (backend Slice B7).
// See: Docs/Roadmap/compliance-checker-clause-library-work-scope.md — Slice B10

import { useState, useEffect, useCallback, useRef } from 'react';
import type { Clause, ClauseCategory } from '../../types/clause';
import { clauseActionsApi } from '../../api/clauses';
import { useFocusTrap } from '../../hooks/useFocusTrap';
import './clauses.css';

type Props = {
  open: boolean;
  onClose: () => void;
  onSaved: (clause: Clause) => void;
  workspaceId: string;
  /** Pre-filled HTML content from editor selection. */
  initialContentHtml: string;
  /** Pre-filled plain text from editor selection. */
  initialContentText: string;
};

const CATEGORY_OPTIONS: { value: ClauseCategory; label: string }[] = [
  { value: 'general', label: 'General' },
  { value: 'legal', label: 'Legal' },
  { value: 'financial', label: 'Financial' },
  { value: 'boilerplate', label: 'Boilerplate' },
  { value: 'custom', label: 'Custom' },
];

/** Max characters for content preview in the dialog. */
const PREVIEW_MAX = 200;

export default function SaveClauseDialog({
  open,
  onClose,
  onSaved,
  workspaceId,
  initialContentHtml,
  initialContentText,
}: Props) {
  const dialogRef = useRef<HTMLDivElement>(null);
  useFocusTrap(dialogRef, open);

  // Form state
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [category, setCategory] = useState<ClauseCategory>('general');
  const [tags, setTags] = useState<string[]>([]);
  const [tagInput, setTagInput] = useState('');

  // Async state
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Reset form when dialog opens with new content
  useEffect(() => {
    if (open) {
      setTitle('');
      setDescription('');
      setCategory('general');
      setTags([]);
      setTagInput('');
      setError(null);
      setSaving(false);
    }
  }, [open]);

  // --- Tag management ---
  const addTag = useCallback(() => {
    const tag = tagInput.trim().toLowerCase();
    if (tag && !tags.includes(tag)) {
      setTags(prev => [...prev, tag]);
    }
    setTagInput('');
  }, [tagInput, tags]);

  const removeTag = useCallback((tagToRemove: string) => {
    setTags(prev => prev.filter(t => t !== tagToRemove));
  }, []);

  const handleTagKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      addTag();
    }
  }, [addTag]);

  // --- Validation ---
  function validate(): string | null {
    if (!initialContentText.trim()) {
      return 'No content to save. Select text in the document first.';
    }
    // Title is optional — backend AI-generates it if empty
    return null;
  }

  // --- Save handler ---
  const handleSave = useCallback(async () => {
    const validationError = validate();
    if (validationError) {
      setError(validationError);
      return;
    }

    setError(null);
    setSaving(true);

    try {
      const res = await clauseActionsApi.fromSelection(workspaceId, {
        contentHtml: initialContentHtml,
        contentText: initialContentText,
        title: title.trim() || undefined,
        description: description.trim() || undefined,
        category,
        tags: tags.length > 0 ? tags : undefined,
      });

      onSaved(res.clause);
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : 'Failed to save clause';
      setError(msg);
    } finally {
      setSaving(false);
    }
  }, [workspaceId, initialContentHtml, initialContentText, title, description, category, tags, onSaved]);

  // --- Keyboard / backdrop ---
  const handleBackdropClick = useCallback((e: React.MouseEvent) => {
    if (e.target === e.currentTarget && !saving) {
      onClose();
    }
  }, [onClose, saving]);

  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Escape' && !saving) {
      e.stopPropagation();
      onClose();
    }
  }, [onClose, saving]);

  if (!open) return null;

  const contentPreview = initialContentText.length > PREVIEW_MAX
    ? initialContentText.slice(0, PREVIEW_MAX).trimEnd() + '\u2026'
    : initialContentText;

  return (
    <div
      ref={dialogRef}
      className="save-clause-backdrop"
      onClick={handleBackdropClick}
      onKeyDown={handleKeyDown}
      role="dialog"
      aria-modal="true"
      aria-labelledby="save-clause-title"
    >
      <div className="save-clause-modal" onClick={e => e.stopPropagation()}>
        {/* Header */}
        <div className="save-clause-header">
          <span id="save-clause-title" className="save-clause-heading">
            Save as Clause
          </span>
          <button
            className="save-clause-close"
            onClick={onClose}
            disabled={saving}
            title="Close"
          >
            {'\u2715'}
          </button>
        </div>

        {/* Body */}
        <div className="save-clause-body">
          {/* Content preview */}
          <div className="save-clause-field">
            <label className="save-clause-label">Selected Content</label>
            <div className="save-clause-content-preview">
              {contentPreview || '(no content)'}
            </div>
          </div>

          {/* Title */}
          <div className="save-clause-field">
            <label className="save-clause-label" htmlFor="save-clause-title-input">
              Title
              <span className="save-clause-hint">Leave blank for AI-generated title</span>
            </label>
            <input
              id="save-clause-title-input"
              className="save-clause-input"
              type="text"
              value={title}
              onChange={e => setTitle(e.target.value)}
              placeholder="e.g. Standard Liability Cap"
              disabled={saving}
            />
          </div>

          {/* Description */}
          <div className="save-clause-field">
            <label className="save-clause-label" htmlFor="save-clause-desc-input">
              Description
              <span className="save-clause-hint">Optional — AI-generated if blank</span>
            </label>
            <textarea
              id="save-clause-desc-input"
              className="save-clause-textarea"
              value={description}
              onChange={e => setDescription(e.target.value)}
              placeholder="What this clause covers..."
              rows={2}
              disabled={saving}
            />
          </div>

          {/* Category */}
          <div className="save-clause-field">
            <label className="save-clause-label" htmlFor="save-clause-category">
              Category
            </label>
            <select
              id="save-clause-category"
              className="save-clause-select"
              value={category}
              onChange={e => setCategory(e.target.value as ClauseCategory)}
              disabled={saving}
            >
              {CATEGORY_OPTIONS.map(opt => (
                <option key={opt.value} value={opt.value}>{opt.label}</option>
              ))}
            </select>
          </div>

          {/* Tags */}
          <div className="save-clause-field">
            <label className="save-clause-label">Tags</label>
            <div className="save-clause-tags-area">
              {tags.map(tag => (
                <span key={tag} className="save-clause-tag">
                  {tag}
                  <button
                    className="save-clause-tag-remove"
                    onClick={() => removeTag(tag)}
                    disabled={saving}
                    title={`Remove "${tag}"`}
                  >
                    {'\u2715'}
                  </button>
                </span>
              ))}
              <input
                className="save-clause-tag-input"
                type="text"
                value={tagInput}
                onChange={e => setTagInput(e.target.value)}
                onKeyDown={handleTagKeyDown}
                onBlur={addTag}
                placeholder={tags.length === 0 ? 'Type a tag and press Enter' : 'Add tag...'}
                disabled={saving}
              />
            </div>
          </div>
        </div>

        {/* Error */}
        {error && (
          <div className="save-clause-error">{error}</div>
        )}

        {/* Footer */}
        <div className="save-clause-footer">
          <button
            className="save-clause-btn ghost"
            onClick={onClose}
            disabled={saving}
          >
            Cancel
          </button>
          <button
            className="save-clause-btn primary"
            onClick={handleSave}
            disabled={saving || !initialContentText.trim()}
          >
            {saving ? 'Saving...' : 'Save Clause'}
          </button>
        </div>
      </div>
    </div>
  );
}
